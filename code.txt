#include <Arduino.h>
#include "BluetoothSerial.h" // Include Bluetooth Serial library

BluetoothSerial BTSerial; // Create Bluetooth Serial object

// Channel addresses for the 14 sensors
byte channel_adress_table[14][4] = {
  { 0, 0, 0, 0 },  { 0, 0, 0, 1 },  { 0, 0, 1, 0 },  { 0, 0, 1, 1 },
  { 0, 1, 0, 0 },  { 0, 1, 0, 1 },  { 0, 1, 1, 0 },  { 0, 1, 1, 1 },
  { 1, 0, 0, 0 },  { 1, 0, 0, 1 },  { 1, 0, 1, 0 },  { 1, 0, 1, 1 },
  { 1, 1, 0, 0 },  { 1, 1, 0, 1 }
};

// MUX variables
#define A 23
#define B 22
#define C 21
#define D 19
#define sensor 4

// Motor driver pins
#define PWMA 32   // Left motor PWM
#define PWMB 12   // Right motor PWM
#define AIN1 25   // Left motor direction
#define AIN2 33   // Left motor direction
#define BIN1 27   // Right motor direction
#define BIN2 14   // Right motor direction
#define STBY 26   // Motor driver standby

// PID constants
double Kp = 1.7;   // Proportional gain
double Ki = 0;   // Integral gain
double Kd = 0;   // Derivative gain

// PID variables
float lastError = 0;
float integral = 0;
const float integralLimit = 1000.0; // Anti-windup limit for the integral term

// Base motor speed
int baseSpeed = 200;

bool motorsEnabled = true; // Track if motors are enabled

// Sensor threshold value
int thresholdValue = 3500;

void setup() {
  Serial.begin(115200); // Initialize serial communication for debugging
  BTSerial.begin("ESP32_PID_Controller"); // Start Bluetooth SPP with a device name
  Serial.println("Bluetooth initialized. Connect to 'ESP32_PID_Controller'.");

  // Set up MUX pins
  pinMode(A, OUTPUT);
  pinMode(B, OUTPUT);
  pinMode(C, OUTPUT);
  pinMode(D, OUTPUT);
  pinMode(sensor, INPUT);

  // Set up motor driver pins
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);

  // Enable motor driver initially
  digitalWrite(STBY, HIGH);
}

void loop() {
  // Handle Bluetooth commands
  if (BTSerial.available()) {
    String command = BTSerial.readStringUntil('\n');
    processBluetoothCommand(command);
  }

  // Line following logic
  int position = readLine();

  if (position == -1 || position == -2) { // No sensors detected a line
    setMotorSpeeds(0, 0); // Stop the motors
    return;
  }
  if(position == -3)
  {
    setMotorSpeeds(250, 250);
    delay(50);
  }

  int error = position - 6500; // Center the line position (6500 is the mid-point)
  error = map(error, -6500, 6500, -255, 255);

  // Compute PID values
  float proportional = error;
  integral += error;

  // Anti-windup: Clamp integral to prevent excessive growth
  integral = constrain(integral, -integralLimit, integralLimit);

  float derivative = error - lastError;
  float correction = (Kp * proportional) + (Ki * integral) + (Kd * derivative);
  lastError = error;

  // Adjust motor speeds
  int leftSpeed = baseSpeed + correction;
  int rightSpeed = baseSpeed - correction;

  leftSpeed = constrain(leftSpeed, -250, 250); // Adjust max value if needed
  rightSpeed = constrain(rightSpeed, -250, 250);

  // Set motor speeds, including reversing if needed
  setMotorSpeeds(leftSpeed, rightSpeed);

  delay(10); // Adjust delay as needed
}

int readLine() {
  static unsigned long noLineStart = 0; // Track when no line was first detected
  int sums = 0;
  int active = 0;
  int overThresholdCount = 0;

  for (int i = 0; i < 14; i++) {
    // Set MUX channel address
    digitalWrite(D, channel_adress_table[i][0]);
    digitalWrite(C, channel_adress_table[i][1]);
    digitalWrite(B, channel_adress_table[i][2]);
    digitalWrite(A, channel_adress_table[i][3]);

    // Read sensor value
    int sens = analogRead(sensor);
    if (sens > thresholdValue) {
      overThresholdCount++; // Count sensors with values over thresholdValue
    }
    sens = (sens > thresholdValue) ? 1 : 0; // Active-low logic

    // Weighted sum calculation
    sums += sens * i * 1000;
    active += sens;
  }

  // Handle no line detected condition
  if(overThresholdCount > 5)
  return -2;

  if (overThresholdCount > 2) {
    // sums = 0;
    // active = 0;
    // int centerStart = 7;
    // int centerEnd = 8;

    // for (int i = centerStart; i <= centerEnd; i++) {
    //   // Set MUX channel address
    //   digitalWrite(D, channel_adress_table[i][0]);
    //   digitalWrite(C, channel_adress_table[i][1]);
    //   digitalWrite(B, channel_adress_table[i][2]);
    //   digitalWrite(A, channel_adress_table[i][3]);

    //   // Read sensor value
    //   int sens = analogRead(sensor);
    //   sens = (sens > thresholdValue) ? 1 : 0; // Active-low logic

    //   sums += sens * i * 1000;
    //   active += sens;
    // }
    return -3;
  }
  if (active == 0) {
    if (noLineStart == 0) {
      noLineStart = millis(); // Start the timer
    } else if (millis() - noLineStart >= 500) {
      return -1; // Return -1 if active == 0 for 1000ms
    }
  } else {
    noLineStart = 0; // Reset the timer if line is detected
  }

  return (active > 0) ? sums / active : 6500; // Return position or default to center
}

void setMotorSpeeds(int leftSpeed, int rightSpeed) {
  // Left motor
  if (leftSpeed >= 0) {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
  } else {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
    leftSpeed = -leftSpeed; // Reverse direction and use absolute speed
  }
  analogWrite(PWMA, leftSpeed);

  // Right motor
  if (rightSpeed >= 0) {
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  } else {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
    rightSpeed = -rightSpeed; // Reverse direction and use absolute speed
  }
  analogWrite(PWMB, rightSpeed);
}

void processBluetoothCommand(String command) {
  command.trim(); // Remove any trailing or leading whitespace
  if (command.startsWith("Kp=")) {
    Kp = command.substring(3).toFloat();
    BTSerial.printf("Updated Kp to %.2f\n", Kp);
  } else if (command.startsWith("Ki=")) {
    Ki = command.substring(3).toFloat();
    BTSerial.printf("Updated Ki to %.2f\n", Ki);
  } else if (command.startsWith("Kd=")) {
    Kd = command.substring(3).toFloat();
    BTSerial.printf("Updated Kd to %.2f\n", Kd);
  } else {
    BTSerial.println("Invalid command. Use Kp=, Ki=, or Kd=");
  }
}
